{"componentChunkName":"component---src-templates-blog-post-js","path":"/block-user-from-leaving-page-on-single-page-app","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Heyjiawei Blog"}},"markdownRemark":{"id":"36789b09-05e8-5343-9b82-cacc983a4443","excerpt":"In the event you don’t understand this article, here’s the talk, here’s the slides I used for the talk and here’s the demo I created to understand this better…","html":"<blockquote>\n<p>In the event you don’t understand this article, <a href=\"https://www.youtube.com/watch?v=vrgtu_5v9jA&feature=youtu.be\" target=\"_blank\">here’s</a> the talk, <a href=\"https://slides.com/chongjiawei/is-it-possible-to-block-users-from-leaving-a-page-on-a-single-page-app\" target=\"_blank\">here’s</a> the slides I used for the talk and <a href=\"https://github.com/heyjiawei/popup-on-leaving-page-demo\" target=\"_blank\">here’s</a> the demo I created to understand this better.</p>\n</blockquote>\n<p>I first stumbled on this problem when I was creating a page containing forms in our internal portals. One of our requirements for a page containing forms is that <em>clients should see a popup to inform them that they are leaving the page. The popup should allow them to select whether to leave or stay on the page</em>. This requirement was implemented in our older internal portals which was the traditional web page where each page is a new page sent by the server. So, it seemed rather obvious that we should be able to implement it in our new portal.</p>\n<p>Our new internal portal however, was designed as a SPA (Single Page Application) and was built with React, with <a href=\"https://reach.tech/router\" target=\"_blank\">Reach Router</a> as our choice of router. <a href=\"https://reach.tech/router/credits\" target=\"_blank\">It was unfortunate that Reach Router does not support this feature</a>, which is coined by them as <strong>History blocking</strong>.</p>\n<p>Nevertheless, I did some digging, only to find that <a href=\"https://github.com/ReactTraining/history/issues/690\" target=\"_blank\">history blocking was never fully working</a> in the earlier versions. The reasons given was as follows, of which I cannot make sense of then:</p>\n<blockquote>\n<ul>\n<li>there is no way we the developers can prevent the user from changing the URL, so we have to try and fake it</li>\n<li>when the URL changes, we fire all the <code class=\"language-text\">history.block</code> callbacks</li>\n<li>if any one of them prevents navigation (e.g. return false), try to revert the URL change</li>\n<li>in conclusion, there is no way to revert the URL change because there is no API in the browser to tell you the last URL you were at. It is a security measure by the browsers</li>\n</ul>\n</blockquote>\n<p>And now its possible. Why? What changed?</p>\n<h2 id=\"before-we-move-on-we-need-to-understand-the-following\" style=\"position:relative;\"><a href=\"#before-we-move-on-we-need-to-understand-the-following\" aria-label=\"before we move on we need to understand the following permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Before we move on, we need to understand the following:</h2>\n<ol>\n<li>Routing on SPA vs Traditional web page routing</li>\n<li>History API</li>\n<li>window.popstate event</li>\n<li>history blocking strategy from React Router</li>\n</ol>\n<h3 id=\"routing\" style=\"position:relative;\"><a href=\"#routing\" aria-label=\"routing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Routing</h3>\n<p>Traditional pages serve up a new page on every navigation. If you check your network tab in your browser, on navigation, you would see a new HTML page and its resources being sent. This new page loads a new document every time. Therefore, traditional web pages can use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event\" target=\"_blank\">beforeunload event</a> to provide us with the feature we want. Also, note that this event is <strong>cancellable</strong>. That means developers can use <code class=\"language-text\">event.preventDefault()</code> to prevent the event from happening.</p>\n<p>SPA on the other hand have to implement their own routing. On clicking a link (or navigation actions), SPA should not make a request to the server to fetch a new fresh HTML page. The URL can change but the document should stay the same.</p>\n<ul>\n<li>So previously in traditional web page, 1 URL would usually be tied to a single page and the routing is handled on the server side. (Let’s disregard the hash on URLs)</li>\n<li>With SPA, routing is handled on the client side by the SPA itself. On matching a route, it will trigger the rerender of the app. <strong>This means that your URL and document are now independent of of each other and your SPA has to synchronise them to mimic traditional web pages behaviour</strong></li>\n</ul>\n<h3 id=\"history-api\" style=\"position:relative;\"><a href=\"#history-api\" aria-label=\"history api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>History API</h3>\n<p><a href=\"https://blog.pshrmn.com/how-single-page-applications-work/\" target=\"_blank\">So how does the SPA implement routing?</a> It does it with the help of this <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History\" target=\"_blank\">History API</a>. Why can’t you use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Location\" target=\"_blank\">Location API</a> <code class=\"language-text\">location.href</code> to navigate the page? <a href=\"https://stackoverflow.com/questions/47583856/window-location-href-vs-history-pushstate-which-to-use\" target=\"_blank\">It will cause the browser to navigate to a new location. It also makes a new HTTP request.</a></p>\n<p>The history api allows us to:</p>\n<ul>\n<li>reuse the active document</li>\n<li>update the URL and also simultaneously add this new URL location into the browser history session</li>\n<li>store a state with a URL location</li>\n<li>call the browser’s back or forward action or go to any history session entry in the history session stack via <code class=\"language-text\">go()</code></li>\n</ul>\n<p>However, it has a few limitations:</p>\n<ul>\n<li>You cannot manipulate the history object</li>\n<li>You will not know the previous locations, despite having the means to traverse to them</li>\n</ul>\n<h3 id=\"popstate-event\" style=\"position:relative;\"><a href=\"#popstate-event\" aria-label=\"popstate event permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Popstate event</h3>\n<p><code class=\"language-text\">beforeunload</code> event does not work on SPA “pages”. But there is a similar event for SPA and that is <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event\" target=\"_blank\">popstate event</a>. Popstate event is triggered by any of the following:</p>\n<ol>\n<li>A browser action such as clicking the forward button</li>\n<li>A browser action such as clicking the back button</li>\n<li>Calling <code class=\"language-text\">history.back()</code></li>\n<li>Calling <code class=\"language-text\">history.forward()</code></li>\n</ol>\n<p>Also, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate\" target=\"_blank\">popstate is fired only when the user navigates between 2 history entries for the same document;</a> popstate event is not cancellable.</p>\n<p>The MDN web document has a section of when popstate event is fired in the sequence of events and here is a summary of what we need to note:</p>\n<ol>\n<li>On click of browser button action</li>\n<li>New location is loaded; This means URL will change and display the next location</li>\n<li>popstate event is sent</li>\n</ol>\n<p>We can see that the <strong>URL location changed before popstate event is sent.</strong> Therefore, within the popstate event listener, we can expect the URL location to be the different from that of the current page.</p>\n<h3 id=\"history-blocking-strategy-from-react-router\" style=\"position:relative;\"><a href=\"#history-blocking-strategy-from-react-router\" aria-label=\"history blocking strategy from react router permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>History blocking strategy from React Router</h3>\n<p><strong>Update: 8 August 2020:</strong>\nThere are 2 ways history blocking will activate. The first is an in-app redirection; when you click on a redirect link within the SPA. The second is when you click on a browser back or forward button. An in-app redirection can be handled by checking if the new location is a blocked location. However the second redirection has to be caught and handled with popstate event handler; This section explains the history blocking strategy of the second redirection method.</p>\n<p>As <code class=\"language-text\">popstate</code> event cannot be cancelled, history blocking is done as follows:</p>\n<ol>\n<li>On page load, instantiate an array. This array will be used to track the history location. Let the first page we are at be index 0.</li>\n<li>When <code class=\"language-text\">popstate</code> event occured, the URL location would have changed to the new location, even when the document hasn’t. We get the new URL location state and give it <code class=\"language-text\">index = index + 1</code>.</li>\n<li>From this array of index, we find <code class=\"language-text\">delta</code>, whereby <code class=\"language-text\">delta = currentPageIndex - redirectedPageIndex</code>. The redirected page refers to the page that you have landed on when a browser action is clicked. We shall use the term redirectedPageIndex to refer to the <code class=\"language-text\">history.state</code> index we store on this redirected page. Take note that we will always land on this redirected page because the <strong>URL location changed before popstate event is sent.</strong></li>\n</ol>\n<h4 id=\"here-is-the-confusing-part\" style=\"position:relative;\"><a href=\"#here-is-the-confusing-part\" aria-label=\"here is the confusing part permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Here is the confusing part:</h4>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/92cb52b3a7fb838a4077a4fddf929ff6/22c86/history-stack.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.59580052493438%; position: relative; bottom: 0; left: 0; background-image: url('data:image/svg+xml,%3csvg%20xmlns=\\'http://www.w3.org/2000/svg\\'%20width=\\'400\\'%20height=\\'134\\'%3e%3cpath%20d=\\'M76%2027v8h95V18H76v9m1-7v7l1%206h46l46%201V19h-46l-47%201m-1%2027v8h95V38H76v9m1%200v7h93V39H77v8m120%206c0%202-2%203-5%202s-4%200-4%202h5v1h3l5-1h2c1%202%207%202%207%201l2-1h2c1%202%205%202%208%200h4l4%201c2%200%203%200%202%201l-1%202%202-1%203-1%205-1h4l5%201c3%200%204%200%203-1-2%200-2%200-1-1l1-2h-3c-1%201-1%201-1-1s0-2-1-1c0%202-1%202-4%202l-2%201-1%201v-3l-2%202h-1c-1-2-1-2-3-1l-2%201h-1l-6-2-5-1c-1%202-2%203-4%202h-17c-1%202-2%201-1%200v-2h-2M78%2060c-2%200-2%201-2%208v8h95V60l-1%207v8H77v-7c0-7%200-7%202-7l47-1%2045-1h-45l-48%201m-2%2022v15h95V80H76v2m1%207v7h93V81H77v8m161%207c0%202-1%202-4%202l-2%201-1%201v-3l-2%202h-8l-4-1c-3-2-4-2-5-1s-13%202-15%201l-3%201c-2%202-2%202%200%202l2-1h5c1%202%205%203%205%201l2-1h8l4%201c2%200%203%200%202%201-1%200-1%202%201%202l1-1c0-1%201-2%202-1l5-1h4l5%201c3%200%204%200%203-1-2%200-2-1-1-1%202%200%201-2%200-2l-2%201-1-1-1-2\\'%20fill=\\'%23d3d3d3\\'%20fill-rule=\\'evenodd\\'/%3e%3c/svg%3e'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/92cb52b3a7fb838a4077a4fddf929ff6/94563/history-stack.webp 163w,\n/static/92cb52b3a7fb838a4077a4fddf929ff6/647a8/history-stack.webp 325w,\n/static/92cb52b3a7fb838a4077a4fddf929ff6/c1dc5/history-stack.webp 650w,\n/static/92cb52b3a7fb838a4077a4fddf929ff6/1e975/history-stack.webp 975w,\n/static/92cb52b3a7fb838a4077a4fddf929ff6/7e370/history-stack.webp 1143w\"\n          sizes=\"(max-width: 650px) 100vw, 650px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/92cb52b3a7fb838a4077a4fddf929ff6/222b7/history-stack.png 163w,\n/static/92cb52b3a7fb838a4077a4fddf929ff6/ff46a/history-stack.png 325w,\n/static/92cb52b3a7fb838a4077a4fddf929ff6/a6d36/history-stack.png 650w,\n/static/92cb52b3a7fb838a4077a4fddf929ff6/e548f/history-stack.png 975w,\n/static/92cb52b3a7fb838a4077a4fddf929ff6/22c86/history-stack.png 1143w\"\n          sizes=\"(max-width: 650px) 100vw, 650px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/92cb52b3a7fb838a4077a4fddf929ff6/a6d36/history-stack.png\"\n          alt=\"Image of history stack referring to current page and redirected page\"\n          title=\"Image of history stack referring to current page and redirected page\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Image of history stack referring to current page and redirected page</figcaption>\n  </figure></p>\n<p>If it is a back action, <code class=\"language-text\">delta</code> would be positive because the currentPageIndex would be larger than the redirectedPageIndex. Remember that the <strong>URL location changed</strong> so we are calling <code class=\"language-text\">go()</code> from the redirected page. Hence, we have to go back to current page so that the user still sees the right URL and we can display the history blocking popup. Therefore, delta is positive because it is inverted to oppose the change; <code class=\"language-text\">go(delta)</code> allows us to go back to the current page and give the illusion that we are pending on the user’s decision - to redirect or not.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/005195b48c803200f4660e862ea8bc9a/712f7/location-timeline.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.321761219305674%; position: relative; bottom: 0; left: 0; background-image: url('data:image/svg+xml,%3csvg%20xmlns=\\'http://www.w3.org/2000/svg\\'%20width=\\'400\\'%20height=\\'81\\'%3e%3cpath%20d=\\'M298%2045c-1%203%200%205%201%203s6-2%207-1c1%204-2%206-4%204-1-2-2-2-2-1l-2%202c-3%203%201%204%2011%203%202%200%201-3-1-3l-1-2%201-2h3l2-1h-1l-1-2c1-2%200-3-1-1h-10c-1-1-2-1-2%201\\'%20fill=\\'%23d3d3d3\\'%20fill-rule=\\'evenodd\\'/%3e%3c/svg%3e'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/005195b48c803200f4660e862ea8bc9a/94563/location-timeline.webp 163w,\n/static/005195b48c803200f4660e862ea8bc9a/647a8/location-timeline.webp 325w,\n/static/005195b48c803200f4660e862ea8bc9a/c1dc5/location-timeline.webp 650w,\n/static/005195b48c803200f4660e862ea8bc9a/1e975/location-timeline.webp 975w,\n/static/005195b48c803200f4660e862ea8bc9a/a110d/location-timeline.webp 1181w\"\n          sizes=\"(max-width: 650px) 100vw, 650px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/005195b48c803200f4660e862ea8bc9a/222b7/location-timeline.png 163w,\n/static/005195b48c803200f4660e862ea8bc9a/ff46a/location-timeline.png 325w,\n/static/005195b48c803200f4660e862ea8bc9a/a6d36/location-timeline.png 650w,\n/static/005195b48c803200f4660e862ea8bc9a/e548f/location-timeline.png 975w,\n/static/005195b48c803200f4660e862ea8bc9a/712f7/location-timeline.png 1181w\"\n          sizes=\"(max-width: 650px) 100vw, 650px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/005195b48c803200f4660e862ea8bc9a/a6d36/location-timeline.png\"\n          alt=\"Image of page location and history stack index along a timeline\"\n          title=\"Image of page location and history stack index along a timeline\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Image of page location and history stack index along a timeline</figcaption>\n  </figure></p>\n<ol start=\"4\">\n<li>The user will then see the popup dialog on the current page. If the user clicks cancel, they will remain on the page. If they choose to leave, we will call <code class=\"language-text\">go(delta * -1)</code>. The <code class=\"language-text\">-1</code> signifies the inverse. That is, <code class=\"language-text\">go(delta)</code> is called from the redirected page to reach the current page. So from current page, it has to call the inverse, which is <code class=\"language-text\">delta * -1</code> to go back to the redirected page.</li>\n</ol>\n<h2 id=\"why-was-history-blocking-previously-concluded-as-impossible\" style=\"position:relative;\"><a href=\"#why-was-history-blocking-previously-concluded-as-impossible\" aria-label=\"why was history blocking previously concluded as impossible permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why was history blocking previously concluded as impossible?</h2>\n<p>In popstate event listener, the URL would have already changed to the new location. We will need to change the URL location back to that of the current location but we have no way of doing so because we can’t tell which browser action caused popstate event to be sent; <strong>popstate event doesn’t tell us whether the back button or forward button triggered it.</strong></p>\n<p>To tackle the issue of <em>we don’t know whether the back button or forward button triggered popstate</em>, the creator(s) of react router first tried to solve this by creating an array that stores the location the user has visited. From there, react router can then calculate where the new location is and how to get back to the current location.</p>\n<p>But this solution has a drawback. This array is instantiated when <code class=\"language-text\">createBrowserHistory()</code> is called. And <code class=\"language-text\">createBrowserHistory()</code> is called when the SPA is loaded. This means that on refresh, the array would start anew too.</p>\n<p>In earlier versions of react router (around 2015), this array was stored in <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage\" target=\"_blank\">session storage</a>. However, this caused <a href=\"https://github.com/ReactTraining/history/issues/42\" target=\"_blank\">issues in Safari’s incognito mode.</a> Apparently, <a href=\"https://stackoverflow.com/questions/21159301/quotaexceedederror-dom-exception-22-an-attempt-was-made-to-add-something-to-st\" target=\"_blank\">in Safari’s private browsing mode, localsession and sessionstorage are both unavailable then.</a> Safari has since fixed the <a href=\"https://bugs.webkit.org/show_bug.cgi?id=157010\" target=\"_blank\">bug</a> in 2016, but react router has already moved on to their next approach.</p>\n<p>If react router were to switch back to using session storage, it would be constrained by session storage space. As brought up by rpedela in this <a href=\"https://github.com/ReactTraining/history/issues/84\" target=\"_blank\">issue</a>,</p>\n<blockquote>\n<p><em>if the oldest entries are removed and the user navigates to a history entry not stored in session storage, what will happen?</em></p>\n</blockquote>\n<p>I think the algorithm would run its path and see this revisited history entry as a new history entry; it would then add this into session storage. This would then cause a bug because the session storage will no longer be synchronised with history session.</p>\n<p>Anyway, React router next approach was to storing the users location in the created history entry’s <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History/pushState\" target=\"_blank\">state</a>. This is because when popstate event is fired, the state property of the popstate event will contain a copy of the history entry’s state object. But instead of instantiating an array, it uses history state as <em>the</em> array.</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Refresh issue? History state persists</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> browser action? History state persists</li>\n</ul>\n<p>What if we use <code class=\"language-text\">location.href</code> within SPA? Or a manual URL redirect?</p>\n<h4 id=\"case-1-when-we-use-locationhref-to-navigate-to-1-page-in-our-spa-and-then-continue-to-use-react-routers-navigation-api\" style=\"position:relative;\"><a href=\"#case-1-when-we-use-locationhref-to-navigate-to-1-page-in-our-spa-and-then-continue-to-use-react-routers-navigation-api\" aria-label=\"case 1 when we use locationhref to navigate to 1 page in our spa and then continue to use react routers navigation api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Case 1: When we use <code class=\"language-text\">location.href</code> to navigate to 1 page in our SPA, and then continue to use react router’s navigation API</h4>\n<p>When this happens, a new document will be created for that page navigated to with <code class=\"language-text\">location.href</code> and <code class=\"language-text\">createBrowserHistory()</code> will run again. The history state will reset as though its the first time we enter the page.</p>\n<p>When we go to a previous page with the browser back or forward button, the history state tied to that page would still exist. Hence, we can still calculate the <code class=\"language-text\">delta</code> value.</p>\n<h4 id=\"case-2-when-we-completely-use-locationhref-to-navigate-within-our-spa\" style=\"position:relative;\"><a href=\"#case-2-when-we-completely-use-locationhref-to-navigate-within-our-spa\" aria-label=\"case 2 when we completely use locationhref to navigate within our spa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Case 2: When we completely use <code class=\"language-text\">location.href</code> to navigate within our SPA</h4>\n<p>If we were to traverse from one page of index 0 to another page of index 0, it is equivalent of traversing to 2 different documents and <code class=\"language-text\">beforeunload</code> event will be fired instead of <code class=\"language-text\">popstate</code> event. However, there is a caveat with <code class=\"language-text\">beforeunload</code> event. The beforeunload dialog box doesn’t always appear even when beforeUnload handler is set up. This is because according to this section of HTML whatwg spec,</p>\n<blockquote>\n<p>The user agent is encouraged to avoid asking the user for confirmation if it judges that doing so would be annoying, deceptive, or pointless. A simple heuristic might be that if the user has not interacted with the document, the user agent would not ask for confirmation before unloading it.</p>\n</blockquote>\n<p><a href=\"https://www.chromestatus.com/feature/5082396709879808\" target=\"_blank\">Here is a more concise explanation by chrome status</a>: The beforeunload dialog will only be shown if the frame attempting to display it has received a user gesture or user interaction (or if any embedded frame has received such a gesture). (There will be no change to the dispatch of the beforeunload event, just a change to whether the dialog is shown.)</p>\n<h1 id=\"so-we-can-block-the-user-from-leaving-the-page-on-a-single-page-app\" style=\"position:relative;\"><a href=\"#so-we-can-block-the-user-from-leaving-the-page-on-a-single-page-app\" aria-label=\"so we can block the user from leaving the page on a single page app permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>So we can block the user from leaving the page on a single page app?</h1>\n<p>Yes, if we keep to the following limitations:</p>\n<ol>\n<li>Navigate within the SPA with history library’s push instead of the browser’s history API (i.e. <code class=\"language-text\">window.history.pushState</code>) directly. This is because the history package uses <code class=\"language-text\">history.state</code> to keep track of its location and the history library’s push API handles this.</li>\n<li>Try not to use <code class=\"language-text\">location.href</code> to navigate within the SPA. The beforeunload dialog box doesn’t always appear even when beforeunload handler is set up. This is a specified behaviour in HTML whatwg spec.</li>\n<li>The browser must support history API.</li>\n</ol>","frontmatter":{"title":"How to block user from leaving a page on a single page app","date":"August 04, 2020","description":"How to block users from leaving a page on a single page app and its limitations"}}},"pageContext":{"slug":"/block-user-from-leaving-page-on-single-page-app","previous":{"fields":{"slug":"/how-to-read-css-specification-syntax"},"frontmatter":{"title":"How to read the CSS specification syntax, a.k.a. CSS Property value syntax"}},"next":null}}}